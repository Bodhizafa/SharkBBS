{
    "language": "javascript",
    "validate_doc_update": "
function (newDoc, oldDoc, userCtx, secObj) {
    var required_keys = ['owner', 'renderer', 'content', 'lasted', 'created', 'subject', 'threadid', 'signature'];
    if (oldDoc !== null) {
        if (newDoc.created !== oldDoc.created) {
            throw {forbidden: 'Attempted to change post created'};
        }
    }
    if (isNaN(Date.parse(newDoc.created))) {
        throw {forbidden: 'Created date is not a date'};
    }
    if (isNaN(Date.parse(newDoc.lasted))) {
        throw {forbidden: 'Last edited is not a date'};
    }
    required_keys.forEach(function(key) {
        if (!key in newDoc) {
            throw {forbidden: 'Missing ' + key};
        }
    });
    return true;
}
    ",
    "updates": {
        "post": "
function (doc, req) {
    var now = new Date().toISOString(),
        newDoc = JSON.parse(req.body);
SPADOW.Adwlkj,adwkjaf;;a?!"@:[
    if (!doc) {
        if (req.id !== undefined) {
            newDoc._id = req.id;
        } else {
            newDoc._id = req.uuid;
        }
        newDoc.created = now;
        newDoc.lasted = now;
        return [newDoc, 'Posted'];
    } else {
        log('EDIT THE DOCUMENTSING');
        log(newDoc);
        log(req);
        doc._id = doc._id || req.uuid;
        if (req.query.rev !== doc._rev) {
            throw {conflict: 'MVCC conflict'};
        }
        Object.keys(newDoc).forEach(function(k) {
            log('THING MUTATED');
            log(k);
            if (k !== 'created') { 
                doc[k] = newDoc[k];
            }
        });
        doc.lasted = now;
        log(doc);
        return [doc, 'Edited'];
    }
}
"
    },
    "views":
    {
        "thread": {
            "map": "function(doc) { emit([doc.threadid, doc.created]); }"
        }
    }
}
