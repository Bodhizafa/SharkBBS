<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<script charset="utf-8" type="application/javascript" src="d3.js"></script>
<style type="text/css">
/* (C) 2015-2016 Landon Meernik, all rights reserved */
/*
This is made up of
    cyan borders and text,
    orange bordered interactables,
    white user content,
    black background,
    and a dash of #222
*/
/* Overall Bullshit */
body {
    font-family: monospace;
    background-color: black;
    color: #0FF;
    margin: 0;
    padding-bottom: 10pt; /* Good things are measured in points */
}
input,textarea,button,#topbar a {
    background-color: #222;
    border: 1pt solid orange;
    color: orange;
    font-family: monospace;
    border-radius: 3pt;
}
button {
    color: #0FF;
    padding: 1pt 6pt;
}
.clearer {
    clear: both;
    margin: 0;
    padding: 0;
}
#template {
    display: none;
}
input[type="test"]:disabled {
    background: #000;
}
/* Bullshit for static elements and containers */
#topbar {
    padding: 2pt;
    position: static;
    width:100%;
    margin: 3pt 0 3pt 0;
    padding-bottom: -1pt;
    border-bottom: 1pt solid #0FF;
}
#topbar a {
    text-decoration: none;
    padding: 1pt 6pt;
    color: #0FF;
    margin-bottom: -4pt;
}
#topbar a.active {
    border-color: #0FF;
}
.posts {
    margin: 0 5ex 0 5ex;
}
#base_posted {
    position: relative;
    top: 10pt;
}
/* Bullshit for Users and Profiles */
.miniprofile .nick {
    font-size: 14pt;
    color: #0FF;
    vertical-align: middle;
    display: inline-block;
}
.miniprofile {
    font-family: monospace;
    border: 1pt solid #0FF;
    border-radius: 3pt;
    display: inline-block;
}
img.avatar {
    vertical-align: middle;
    width: 32pt;
    height: 32pt;
    margin: 2pt;
    float: left;
}
/* Bullshit for posts */
.post .signature {
    white-space: pre-wrap;
    padding: 6pt 3pt 6pt 3pt;
    font-size: 10pt;
}
.post .subject {
    font-size: 13pt;
    font-weight: bold;
    padding: 3pt;
}
.post {
    border: 1pt solid #0FF;
    border-radius: 3pt;
    margin: 14pt 0 0 0;
    clear: both;
}
.post .header {
    border: 1pt solid #0FF;
    border-width: 1pt;
    margin: -1pt -1pt 0 -1pt;
    border-radius: 3pt;
    border-right: 1pt solid #0FF;
}
.post .lasted {
    font-size: 10pt;
    padding-left: 4ex;
    float: left
}
.post .content {
    white-space: pre-wrap;
    color: #FFF;
    border-top-left-radius: 3pt;
    border-top-right-radius: 3pt;
    border: 1pt solid #0FF;
    border-bottom: 0;
    margin: 2pt -1pt 0 5pt;
    padding: 3pt;
}
.post .footer {
    margin-top: -1pt;
}
.post .footer .container {
    display: inline;
    float: right;
    border-radius: 3pt;
    border-bottom: 1pt solid #000;
    margin: -11pt 6pt -1pt 0;
}
.post .footer button {
    margin: 0 -1pt -1pt 0;
    display: none;
}
/* Bullshit for miniprofiles in posts */
.post .miniprofile {
    margin: -1pt 3pt -1pt -1pt;
    float: left;
}
/* Bullshit for normal posts (replies) */
.post.reply .interject {
    display: initial;
}
/* Bullshit for the OP */
.post.op div, .post.op {
    border-color: orange
}
.post.op .subject{
    color: orange
}
.post.op .unload {
    display: initial;
}
.post.op .interject {
    display: initial;
}
/* Bullshit for interjection stubs */
.post.interjection {
    margin-left:48pt;
}
.post.interjection .content {
    display: none;
}
.post.interjection .signature {
    display: none;
}
.post.interjection .load {
    display: initial;
}
.post.interjection.posted .load {
    display: none;
}
.post.interjection.posted .delete {
    display: none;
}
.post.interjection.posted .content {
    display: initial;
}
.post.interjection.posted .signature {
    display: block;
}
/* Bullshit for the post editor */
.post textarea.content {
    width: calc(100% - 12pt);
    max-width: calc(100% - 12pt);
    border: 1pt solid orange;
    height: 15em;
}
.post input.subject {
    width: 25ex;
    display: block;
    font-weight: normal;
    font-size: 12pt;
}
.post.posted .save {
    display: initial;
}
.post.posted.interjection .save {
    display: none;
}
.post.posted .cancel {
    display: initial;
}
.post.posted .edit {
    display: none !important;
}
.post.replyed .reply {
    display: initial;
}
/* Bullshit for my posts */

.post.mine .edit {
    display: initial;
}
.post.mine .delete {
    display: initial;
}
/* Bullshit for the formatter */
.formatted .quote {
    white-space: pre;
    color: green;
}
.formatted a {
    color: orange;
}
.formatted img {
    max-width: 500pt;
    max-height: 500pt;
}
.unformatted {
    white-space: pre;
    color: red;
}
/* Other bullshit */
textarea.help {
    max-width: 120ex;
    width: 100%;
    height: 30em;
}
</style>
<title>...</title>
<script>
"use strict";
// Model - Literally a picture of how data is literally shaped on the backend
/*
thread_id is the id of the thread you would be replying to if you hit 'reply'.

|-  means: thread_id points to ID of post in the column where | is.
|-- means: '' and also this is an interjection on the |-'d post closest above it (its parent_id points there)

"0" (default thread_id)
-(Reply0)                       # Reply0 is the OP (post with _id = thread_id)
|-Reply1
|-Reply2                        # There is no Reply2Int0.
|--Reply2Int1  (Reply0)         # Identified as interjections by having parent_id set
   |-Reply2Int1 Reply1          # not displayed in this thread
   |-...        Reply...
|--Reply2Int2
|-Reply3
|-...
^ current thread_id
>>>^ go in one level by setting current thread_id to Reply2Int1

Reply2Int1 (OP)
|-Reply2Int1Reply1              # displayed in this thread
|-...
<<<^ go up one level by loading OP's thread_id
*/
var users = { // User data. Users missing these fields may not render correctly. There may be more, because #schemaless
    "": { // Defaults
        "nick": "",
        "title": "",
        "avatar": "",
        "signature": ""
    }
}

// DataModel - Metaphorically a picture of how data is literally shaped on the frontend.
document.addEventListener("DOMContentLoaded", function() {
    var user = "", // Current logged in username
        primeUsers = (function(usernames, cb) {
        // `usernames` should be an array of usernames, cb will be invoked when they are all in `users`
            var uncached_by_username = {},
                requests = 0,
                log_cb = (function() {
                    requests--;
                    if (requests <= 0) {
                        console.debug("Primed users cache for ", usernames, "as", user, "result: ", users);
                        cb();
                    }
                });
            console.log("Priming usrs cache, cookie:", document.cookie);
            // Build a list of users we don't have in 'users,' then make a request if there actually are any
            usernames.forEach(function(username) {
                if (!users[username]) {
                    uncached_by_username[username] = true;
                }
            });
            if (Object.keys(uncached_by_username).length === 0) {
                console.debug("Users cache hit all");
                log_cb();
                return;
            }
            // XXX make backend support getting multiple keys at once. As it is we just make a fuckton of requests.
            Object.keys(uncached_by_username).forEach(function(username) {
                requests += 1;
                d3.xhr("/data/users/?id=" + encodeURIComponent(username), function(resp) {
                    var rows = JSON.parse(resp.response);
                    rows.forEach(function(row) {
                        var username;
                        if (row.error) {
                            console.error("Error finding user ", username, ":", row);
                            alert("SHIT POST")
                        }
                        username = row.id;
                        users[username] = row;
                    });
                    log_cb();
                })
                .on("error", function(resp) {
                    console.error("Error priming users cache for ", usernames, ":", resp);
                    alert("SHIT POST!")
                })
                .header("Content-Type", "application/json")
                .send("GET");
            });
        }),
        loadThread = function(new_thread_id) {
        // This function works by making three requests. First it makes one for the OP and one for the replies at the same time.
        // The results are then put into replies and interjections_by_parent_id such that OP is first in replies.
        // When requests reaches zero, actuallyLoadThread is called, it sorts and collates replies into `posts`,
        // Then it compiles a list of usernames owning posts in the thread (which will be required to render), primes the users
        // cache with them (the third request), and then calls renderPosts(posts) once everything is in place
            console.debug("Loading thread ", new_thread_id, "as user", user);
            if (!user) {
                alert("Login first.");
                window.location.hash = "login";
                return;
            };
            // Get the posts
            d3.xhr('/data/posts?thread_id=' + encodeURIComponent(new_thread_id))
                .on("error", function(resp) { console.error(JSON.parse(resp.response)); })
                .on('load', function(resp) {
                    var rows = JSON.parse(resp.response),
                        replies = [rows.shift()],
                        posts = [],
                        interjections_by_parent_id = {},
                        usernames;
                    // First sift through all posts returned and put them in either replies or interjections
                    rows.forEach(function(post) {
                        if (post.parent_id) {
                            if (!interjections_by_parent_id[post.parent_id]) {
                                interjections_by_parent_id[post.parent_id] = [];
                            }
                            post.cssclass = 'interjection';
                            interjections_by_parent_id[post.parent_id].push(post);
                        } else {
                            replies.push(post);
                            post.cssclass = 'reply';
                        }
                    })
                    // Second, reassemble the posts list in the order it should be displayed
                    replies.forEach(function(reply) {
                        posts.push(reply);
                        if (interjections_by_parent_id[reply.id]) {
                            interjections_by_parent_id[reply.id].sort(function(a, b) { return d3.descending(a.lasted, b.lasted); })
                            interjections_by_parent_id[reply.id].forEach(function(interjection) {
                                posts.push(interjection);
                            });
                            delete interjections_by_parent_id[reply.id];
                        }
                    });
                    if (Object.keys(interjections_by_parent_id).length) {
                        console.error("Orphaned posts: ", interjections_by_parent_id);
                        alert("SHIT POST!");
                        return;
                    }
                    // Third, Prime the users cache and render the thread
                    usernames = [user];  // users required to render the current thread (user is required to render replyed)
                    posts.forEach(function(post) {
                        usernames.push(post.owner);
                    })
                    console.debug("Collated posts: ", posts);
                    primeUsers(usernames, function() {
                        renderPosts(posts);
                        // XXX layering violation :(
                        d3.select('#base_posted .thread_id').attr('value', new_thread_id); // XXX should this be property?
                    });
                })
                .send('GET');
        },
        // Given an element which is a post (or post editor), return the post JSON object
        getPost = function(posted) {
        var subject = posted.querySelector('.subject'),
            content = posted.querySelector('.content'),
            signature = posted.querySelector('.signature'),
            owner = posted.querySelector('.owner'),
            thread_id = posted.querySelector('.thread_id'),
            id = posted.querySelector(".id"),
            post = {
                "owner": owner.value || owner.textContent,
                "thread_id": thread_id.value || thread_id.textContent,
                "subject": subject.value || subject.textContent,
                "content": content.value || content.textContent,
                "signature": signature.value || signature.textContent
            };
            if (id && id.value) {
                post.id = id.value;
            }
            return post;
        },
        postPost = function(post, callback) {
            console.log("Attempting to post", post);
            d3.xhr('/data/post')
                .on('error', function(e) {
                    console.error(e);
                    alert("SHIT POST");
                 })
                .on('load', function(resp) {
                    console.log("GOOD JOB", resp.response);
                    callback();
                 })
                .send('POST', JSON.stringify(post));
        },

// Application - Metaphorically a picture of how data is metaphorically shaped on the backend
        // return a 'div' DOM element representing "source" rendered according to the semantics of this function.
        format = function(source) {
            // tokens which can have formatting semantics. They'll show up in the token stream as strings
            var formatting_tokens = ['__', '~~', '**', '//', '>', '*', '\n', '[', ']', '|'],
                parse = (function() {
                    var flatten = function flatten(elemss) {
                            var elems = [];
                            elemss.forEach(function(new_elems) {
                                elems.push.apply(elems, new_elems); // this is really just array concatenation
                            });
                            return elems;
                        },
                        // Wrap elemss[idx] in an elem_type
                        wrap = function wrap (elem_type, idx) {
                            return function(elemss) {
                                var elem = document.createElement(elem_type);
                                for (var i = 0; i < elemss[idx].length; i++) {
                                    elem.appendChild(elemss[idx][i]);
                                }
                                return [elem];
                            };
                        },
                        // Wrap all elements in the given elem_type
                        collect = function collect(elem_type, properties) {
                            if (!properties) {
                                properties = {};
                            }
                            return function(elemss) {
                                var elem = document.createElement(elem_type),
                                    elems = flatten(elemss);
                                elems.forEach(function(e) {
                                    elem.appendChild(e);
                                })
                                Object.keys(properties).forEach(function(k) {
                                    elem.setAttribute(k, properties[k]);
                                })
                                return [elem];
                            }
                        },
                        link_composer = function(elemss) { // [url|spans]
                            var url = elemss[1].map(function(n) { return n.textContent }).join(""),
                                elems = elemss[3],
                                elem = document.createElement('a');
                            elem.setAttribute('href', url)
                            if (elems === undefined) {
                                elem.textContent = url;
                            } else {
                                elems.forEach(function(el) { elem.appendChild(el) });
                            }
                            return [elem];
                        },
                        // I think some nerds call these combinators.
                        // They take some arguments as to what they match, some take a composer as the last argument, which is expected to combine the
                        // results of the subparsers (i.e. take a list of lists of DOM nodes and return a list of DOM nodes)
                        // The functions they return take a stream and return a (perhaps empty) flat list of DOM nodes, or undefined if they did not match.
                        // They advance the tokenstream over what they matched when they do.

                        // Returns a function that looks for 'token' and returns [], no composer
                        tok = function tok(token) {
                            return function tok_generated(token_stream) {
                                if (token_stream.read(1)[0] == token) {
                                    token_stream.advance(1);
                                    return [];
                                }
                            };
                        },
                        // Returns a function that looks for 'token' and returns a singleton list with a text node of said token
                        tok_lit = function tok_lit(token) {
                            return function tok_lit_generated(token_stream) {
                                if (token_stream.read(1)[0] == token) {
                                    token_stream.advance(1);
                                    return [document.createTextNode(token)]
                                }
                            };
                        },
                        // Tries a few things, passes the results of the first match up,
                        // no composer
                        or = function or() {
                            var args = Array.from(arguments)
                            return function or_generated(token_stream) {
                                var elems, i;
                                for (i = 0; i < args.length; i++) {
                                    if (args[i].name === undefined) {
                                        if (grammar[args[i]] === undefined) {
                                            console.error("or could not find at runtime:", args[i]);
                                        }
                                        args[i] = grammar[args[i]];
                                    }
                                    elems = args[i](token_stream)
                                    //console.log("or invoked ", args[i].name, args[i].debug_name, "got", elems, "next", token_stream.read(1));
                                    if (elems !== undefined) {
                                        return elems;
                                    }
                                }
                            }
                        },
                        // Checks for each of its arguments next to eachother.
                        adjacent = function adjacent() {
                            var args = Array.from(arguments),
                                composer = args.pop();
                            return function adj_generated(token_stream) {
                                var pos = token_stream.tell(),
                                    elems,
                                    elemss = [],
                                    i;
                                for (i = 0; i < args.length; i++) {
                                    if (args[i].name === undefined) {
                                        if (grammar[args[i]] === undefined) {
                                            console.error("adjacent could not find at runtime:", args[i]);
                                        }
                                        args[i] = grammar[args[i]];
                                    }
                                    elems = args[i](token_stream)
                                    //console.log("adj invoked ", args[i].name, args[i].debug_name, "got", elems, "next", token_stream.read(1));
                                    if (elems === undefined) {
                                        token_stream.seek(pos);
                                        return;
                                    } else {
                                        elemss.push(elems);
                                    }
                                }
                                return composer(elemss);
                            }
                        },
                        // checks for a given thing next to itself one or many times
                        run = function run(segment, composer) {
                            return function run_generated(token_stream) {
                                var elems,
                                    elemss = [],
                                    i = 0;
                                if (segment.name === undefined) {
                                    if (grammar[segment] === undefined) {
                                        console.error("run could not find at runtime:", segment);
                                    }
                                    segment = grammar[segment];
                                }
                                do {
                                    elems = segment(token_stream);
                                    //console.log("run invoked ", segment.name, segment.debug_name, "got", elems, "next", token_stream.read(1));
                                    if (elems !== undefined) {
                                        elemss.push(elems);
                                    }
                                } while(elems !== undefined);
                                if (elemss.length > 0) {
                                    return composer(elemss);
                                }
                            }
                        },
                        grammar = {
                            'doc'       : adjacent(run('block', collect('div', {'class': 'formatted'})), tok(undefined), flatten),
                            'block'     : or('list', 'quote', 'text'),
                            'text'      : run('line', collect('div')),
                            'line'      : adjacent(or(adjacent('span_noblock', run('span', flatten), flatten), 'span_noblock', 'garbage'), run(tok_lit('\n'), flatten),
                                function (elemss) {
                                    var elems = elemss[0].slice();
                                    elemss[1].forEach(function() {
                                        elems.push(document.createElement('br'));
                                    })
                                    return elems;
                                }),
                            'garbage'   : run(or('content', tok_lit('__'), tok_lit('**'), tok_lit('~~'), tok_lit('//'),
                                                 tok_lit('['), tok_lit('|'), tok_lit(']')), flatten),
                            'span_noblock'      : or('content', 'underlinetext', 'strikethroughtext', 'boldtext', 'italicstext', 'link', 'image'),
                            'span'      : or('content', run('blockfmt', flatten),
                                             'underlinetext', 'strikethroughtext', 'boldtext', 'italicstext',
                                             'link', 'image'),
                            'blockfmt'  : or(tok_lit("*"), tok_lit(">")),
                            'underlinetext' : adjacent(tok('__'), run('span', flatten), tok('__'), wrap('u', 1)),
                            'strikethroughtext' : adjacent(tok('~~'), run('span', flatten), tok('~~'), wrap('del', 1)),
                            'boldtext'  : adjacent(tok('**'), run('span', flatten), tok('**'), wrap('b', 1)),
                            'italicstext'   : adjacent(tok('//'), run('span', flatten), tok('//'), wrap('i', 1)),
                            'link'      : or(adjacent(tok('['), 'url', tok('|'), run('span', flatten), tok(']'), link_composer),
                                             adjacent(tok('['), 'url', tok(']'), link_composer)),
                            'image'     : adjacent(tok('['), 'url', tok('|'), tok(']'),
                                function(elemss) {
                                    var url = elemss[1].map(function(n) { return n.textContent }).join(""),
                                        elem = document.createElement('img');
                                    elem.setAttribute('src', url);
                                    return [elem];
                                }),
                            'url'       : run(or('content', tok_lit('//')), flatten),
                            'list'      : run('listitem', collect('ul')),
                            'listitem'  : adjacent(tok('*'), run('span', flatten), tok('\n'), wrap('li', 1)),
                            'quote'     : run('quoteitem', collect('div', {'class': 'quote'})),
                            'quoteitem' : adjacent(tok_lit('>'), run('span', flatten), tok_lit('\n'), flatten),
                            'content'   : function content(token_stream) {
                                var tok = token_stream.read(1)[0],
                                    elem;
                                if (tok !== undefined && tok.is_content) {
                                    elem = document.createTextNode(tok.join(""));
                                    token_stream.advance(1);
                                    return [elem];
                                }
                            }
                        };
                    Object.keys(grammar).forEach(function(k) {
                        grammar[k].debug_name = k;
                    });
                    return grammar.doc;
                })(),
                token_stream = (function() {
                    var tokens = [],
                        current_token = [], // Use arrays of characters because you can't decorate normal strings and constructing them is slow
                                            // Tokens other than runs of text are still normal strings.
                        skip = 1,
                        matched = false,
                        stream_pos = 0;

                    for (var pos = 0; pos < source.length; pos += skip) {
                        matched = false,
                        formatting_tokens.forEach(function(t) {
                            if (matched) {
                                return;
                            }
                            if (source.substr(pos, t.length) == t) {
                                if (current_token.length) {
                                    current_token.is_content = true; // this token is user content, not formatting metadata
                                    tokens.push(current_token);
                                }
                                current_token = [];
                                tokens.push(t);
                                skip = t.length;
                                matched = true;
                            }
                        })
                        if (!matched) {
                            current_token.push(source[pos]);
                            skip = 1;
                        }
                    }
                    if (current_token) {
                        current_token.is_content = true;
                        tokens.push(current_token);
                    }
                    if (tokens[tokens.length-1] != '\n') {
                        tokens.push("\n");
                    }
                    return {
                        "read": function(n) {
                            return tokens.slice(stream_pos, stream_pos + n);
                        },
                        "advance": function(n) {
                            stream_pos += n;
                        },
                        "seek": function(pos) {
                            stream_pos = pos;
                        },
                        "tell": function() {
                            return stream_pos;
                        },
                        "_token": tokens // for debugging.
                    }
                })(),
                parsetree;
            parsetree = parse(token_stream);
            if (!parsetree) {
                console.error("Post did not format.", token_stream._tokens);
                parsetree = [document.createElement('div')];
                parsetree[0].class = "unformatted";
                parsetree[0].textContent = source;
                return parsetree[0];
            }
            return parsetree[0];

            return elem;
        },
        renderPosts = function(posts) {
        var $posts = d3.select("#posts").selectAll("div.post")
                    .data(posts, function(d) { return d.id;}),
            $npost = $posts.enter()
                    .append('div')
                    .html(d3.select('#template').html()),
            updatePost = function($post) {
            // Set text, value, and src of elements with these classes to their corresponding data.
            var fields = ['id', 'owner', 'subject', 'lasted', 'signature', 'thread_id'],
                ownerFields = ['avatar', 'nick', 'title'];
                fields.forEach(function(field) {
                    var $field = $post.select('.' + field),
                        func = (function(d) { return d[field]; });
                    $field.attr('src', func);
                    $field.attr('value', func);
                    $field.text(func);
                });
                ownerFields.forEach(function(field) {
                    var $field = $post.select('.' + field),
                        func = (function(d) { return users[d.owner][field]; });
                    $field.attr('src', func);
                    $field.attr('value', func);
                    $field.text(func);
                });
                $post.select('.nick').attr('href', function(d) {
                    return '#profile/' + d.owner;
                });
                $post.attr('class', function(d) {
                    if (d.cssclass) return 'post ' + d.cssclass;
                    else return 'post';
                });
                $post.classed('mine', function(d) {
                    return d.owner == user;
                });
                $post.select('.content')
                    .style('display', function(d) {
                        return d.content ? null : "none";
                    })
                    .html("")
                    .append(function(d) {
                        return format(d.content);
                    });
                $post.select('.edit')
                    .on('click', function () {
                        // Clicked "edit"
                        var posted = this.closest('.post'),
                            post = getPost(posted),
                            that = this;
                        d3.select(posted).classed("posted", true);
                        posted.querySelector('.content')
                            .outerHTML = '<textarea class="content">' + post.content + '</textarea>';
                        posted.querySelector('.subject')
                            .outerHTML = '<input class="subject" value="' + post.subject + '" />';
                    });
                $post.select('.cancel')
                    .on('click', function () {
                        var posted = this.closest('.post'),
                            thread = this.closest('.post').querySelector('.thread_id').value;
                        d3.select(posted).classed("posted", false);
                        posted.querySelector('.subject')
                            .outerHTML = '<div class="subject"></div>';
                        posted.querySelector('.content')
                            .outerHTML = '<div class="content"></div>';
                        loadThread(thread);
                    });
                $post.select('.save')
                    .on('click', function () {
                        var posted = this.closest('.post'),
                            post = getPost(posted), // XXX NO DATE
                            thread = d3.select('#base_posted .thread_id').attr('value');
                        console.log("Saving..");
                        postPost(post, function() {
                                // Post has been saved, unhide buttons,
                                d3.select(posted).classed("posted", false);
                                posted.querySelector('.subject')
                                    .outerHTML = '<div class="subject"></div>';
                                posted.querySelector('.content')
                                    .outerHTML = '<div class="content">loading...</div>';
                                loadThread(thread);
                        });
                    });
                $post.select('.delete')
                    .on('click', function() {
                        var id = this.closest('.post').querySelector('.id').value,
                            thread = this.closest('.post').querySelector('.thread_id').value;
                        d3.xhr('/data/unpost?id=' + id)
                        .on('error', function(e) {
                            console.error(e);
                            alert("SHIT POST");
                        })
                        .on('load', function(e) {
                            loadThread(thread)
                        })
                        .send('GET');
                    });
                $post.select('.load')
                    .on('click', function() {
                        window.location.hash = "posts/" + this.closest('.post').querySelector('.id').value;
                    });
                $post.select('.unload')
                    .on('click', function() {
                        window.location.hash = "posts/" + this.closest('.post').querySelector('.thread_id').value;
                    });
                $post.select('.interject')
                    .on('click', function(e) {
                    var $nposted = d3.select(document.createElement("div")),
                        that = this,
                        thread = d3.select('#base_posted .thread_id').attr('value')
                        d3.selectAll('#posts .interject').style('display', 'none');
                        $nposted.html(d3.select('#template').html())
                            .attr('class', "post interjection posted")
                            .attr('id', "")
                        $nposted.select('.subject').node()
                            .outerHTML = '<input class="subject" />';
                        $nposted.select('.content').node()
                            .outerHTML = '<textarea class="content"></textarea>';
                        $nposted.select('.thread_id')
                            .attr('value', thread);
                        $nposted.select('.owner')
                            .attr('value', user);
                        $nposted.select('.signature')
                            .text(users[user].signature);
                        $nposted.select('.signature').text(users[user].signature);
                        $nposted.select('.avatar').attr('src', users[user].avatar);
                        $nposted.select('.title').text(users[user].title);
                        $nposted.select('.nick').text(users[user].nick);
                        $nposted.select('.interject')
                            .style('display', 'initial')
                            .on('click', function() {
                            var post = getPost(this.closest('.post'));
                                post.parent_id = that.closest('.post').querySelector('.id').value;
                                postPost(post, function() {
                                    console.log("INTERJECTED");
                                    loadThread(thread);
                                });
                            });
                        $nposted.datum({});
                        $nposted.select('.cancel')
                            .style('display', 'initial')
                            .on('click', function() {
                                d3.selectAll('#posts .post:not(.interjection) .interject').style('display', 'initial');
                                $nposted.remove();
                            });
                        document.getElementById('posts')
                            .insertBefore($nposted.node(), that.closest('.post').nextSibling)
                    });
            };
            console.log("RENDERING POSTS:", posts);
            $posts.exit().remove();
            updatePost($npost);
            updatePost($posts);
            $posts.order();
            d3.selectAll('#posts .post:not(.interjection) .interject').style('display', 'initial');
            // Set up the reply editor
            d3.select("#base_posted")
                .style('display', 'block')
            d3.select("#base_posted .owner")
                .attr('value', user)
            d3.select('#base_posted .signature').text(users[user].signature);
            d3.select('#base_posted .avatar').attr('src', users[user].avatar);
            d3.select('#base_posted .title').text(users[user].title);
            d3.select('#base_posted .nick').text(users[user].nick);
            d3.select('#base_posted .reply')
                .on('click', function() {
                var posted = this.closest('.post');
                var post = getPost(posted);
                postPost(post, function() {
                    loadThread(post.thread_id);
                    posted.querySelector('.content').value = '';
                });
            });
        },
    // I heard cool kids used hash routers
    // When you navigate to page foo:
    //   The element with class "page" and an ID that starts with foo are set display:block
    //   Other elements with class "page" are hidden. (display:none)
    //   The tab with href "#foo" is set class=active, others have it removed
    //   The function foo in this map is called with the remaining path elements as arguments and #foo_page as this
        routes = {
            'login': function() {
                var $login_page = d3.select(this);
                $login_page.select('button.logout').on('click', function() {
                    d3.xhr('/data/_sessions', function(response) {
                        delete users[user];
                        user = "";
                        $login_page.select('.loggedon').style('display', 'none');
                        d3.selectAll('#posts div.post').remove()
                    })
                    .send('DELETE');
                });
                $login_page.select('button.login').on('click', function() {
                    var username = $login_page.select('.username').property('value'),
                        password = $login_page.select('.password').property('value');
                    console.log('Attempting login as', username, password);
                    d3.xhr('/data/_sessions', function(response) {
                        if (response === null) {
                            console.error('Unsuccessful login');
                            alert('Unauthorized!');
                            return;
                        }
                        console.log('Successful login', response);
                        user = username;
                        primeUsers([user], function() {
                            window.location.hash = 'posts/0';
                        });
                    })
                    .header('Content-Type', 'application/json')
                    .header('Authorization', "Basic " + btoa(username + ":" + password))
                    .send('GET');
                });

                d3.xhr('/data/_sessions')
                .on('load', function(resp) {
                    console.log("Initial login response: ", resp);
                    var doc = JSON.parse(resp.response)
                    user = doc.users_id;
                    $login_page.select('.loggedon').style('display', 'block');
                    $login_page.select('.user').text(user);
                })
                .on('error', function(resp) {
                    console.log("Initial login error: ", resp.response);
                    $login_page.select('.loggedon').style('display', 'none');
                })
                .send('GET');
            },
            'register': function() {
                var $register_page = d3.select(this);
                $register_page.select('button.register').on('click', function() {
                    var username = $register_page.select('input.username').property('value'),
                        nick = $register_page.select('input.nick').property('value'),
                        signature = $register_page.select('input.signature').property('value'),
                        avatar = $register_page.select('input.avatar').property('value'),
                        password = $register_page.select('input.password').property('value'),
                        password2 = $register_page.select('input.password2').property('value'),
                        passcode = $register_page.select('input.passcode').property('value');
                    if (password != password2) {
                        alert('Passwords do not match');
                        return;
                    }
                    if (!username.match(/^\w+$/)) {
                        alert('Username is not a word');
                        return;
                    }
                    d3.xhr(urls.users + '/' + encodeURIComponent('org.couchdb.user:' + username))
                    .on('load', function(resp) {
                        if (resp.status != 201) {
                            alert('SHIT POST ', + resp.status);
                            console.error('Non-201 response', resp);
                        }
                        console.debug('Registered user: ', resp);
                        d3.xhr('/data/_sessions', function(response) {
                            if (response === null) {
                                console.error('Unsuccessful login');
                                alert('Unauthorized!');
                                return;
                            }
                            alert('Registered ' + username + '. :D');
                            user = username;
                            window.location.hash = 'posts/0';
                        })
                        .on('error', function(response) {
                            console.error("Couldn't log in after creating user", username, response);
                            alert('SHIT POST!')
                        })
                        .header('Content-Type', 'application/json')
                        .send('POST', JSON.stringify({
                            'name': username,
                            'password': password}));
                    })
                    .on('error', function(resp) {
                        alert('SHIT POST ' + resp.status);
                        console.error('Something bad happened', resp);
                    })
                    .header('Content-Type', 'application/json')
                    .send('PUT', JSON.stringify({
                        '_id': 'org.couchdb.user:' + username,
                        'name': username,
                        'type': 'user',
                        'roles': [],
                        'password': password,
                        'nick': nick,
                        'signature': signature,
                        'avatar': avatar,
                        'passcode': passcode,
                    }));
                });
            },
            'posts': function(post) {
                if (post) {
                    loadThread(post);
                } else {
                    window.location.hash = 'posts/0';
                    return;
                }
            },
            'profile': function(username) {
                var $profile_page = d3.select(this);
                if (!username) {
                    if (!user) {
                        alert('Login first.');
                        window.location.hash = 'login';
                        return;
                    }
                    window.location.hash = 'profile/' + user;
                    return;
                }
                console.debug('Loading profile for: ', username);
                primeUsers([username], function() {
                    // Damnit, HTML, why is there no consistent "the thing I'm displaying" property/attr/css
                    $profile_page.select('input.username').property('value', username);
                    $profile_page.select('span.username').text(username);
                    $profile_page.select('input.nick').property('value', users[username].nick);
                    $profile_page.select('span.nick').text(users[username].nick);
                    $profile_page.select('img.avatar').attr('src', users[username].avatar);
                    $profile_page.select('input.avatar').property("value", users[username].avatar);
                    $profile_page.select('textarea.signature').property('value', users[username].signature);
                    $profile_page.select('div.signature').text(users[username].signature);
                    $profile_page.select('input.password').property('value', "");
                    $profile_page.select('input.password2').property('value', "");

                    $profile_page.selectAll('tr.password').style('display', user == username ? '' : 'none');
                    $profile_page.selectAll('input').style('display', user == username ? 'inline' : 'none');
                    $profile_page.selectAll('textarea').style('display', user == username ? 'inline' : 'none');
                    $profile_page.selectAll('span').style('display', user == username ? 'none' : 'inline');
                    $profile_page.selectAll('div').style('display', user == username ? 'none' : 'inline');

                    $profile_page.select('button.save')
                    .style('display', user == username ? 'inline' : 'none')
                    .on('click', function() {
                        var fields = {
                                'type': 'user',
                                'nick': $profile_page.select('input.nick').property('value'),
                                'avatar': $profile_page.select('input.avatar').property('value'),
                                'signature': $profile_page.select('textarea.signature').property('value'),
                                'password': $profile_page.select('input.password2').property('value')
                            },
                            inherited_fields = ['_rev', '_id', 'roles', 'name'],
                            password_fields = ['derived_key', 'salt', 'iterations', 'password_scheme'],
                            invalidate_session = true;

                        if (fields.password != $profile_page.select('input.password').property('value')) {
                            alert("Passwords don't match.");
                            return
                        }
                        if (!fields.password) { // If there's no password change, pass through the old password fields
                            delete fields.password;
                            inherited_fields = inherited_fields.concat(password_fields);
                            invalidate_session = false;
                        }
                        inherited_fields.forEach(function(key) {
                            fields[key] = users[user][key];
                        });
                        console.debug("Updating user", user, "to", fields);
                        d3.xhr(urls.users + '/' + encodeURIComponent('org.couchdb.user:' + user))
                        .on('load', function(resp) {
                            delete users[username];
                            if (invalidate_session) {
                                d3.xhr('/data/_sessions')
                                .on('load', function(resp) {
                                    if (!user) {
                                        alert("SHIT POST")
                                        throw "Seriously how did you get here?";
                                    }
                                    delete users[user];
                                    user = "";
                                    alert("Password changed, please relogin");
                                    window.location.hash = "login";
                                })
                                .send("DELETE");
                            } else {
                                alert("Updated!");
                                window.location.hash = "profile";
                            }
                        })
                        .on('error', function(resp) {
                            console.error("User update failed", resp);
                            alert("SHIT POST");
                        })
                        .header('Content-Type', 'application/json')
                        .send('PUT', JSON.stringify(fields));
                    });
                    console.debug("Rendered profile for", username);
                });
            },
            "help": function() {
                var $help_page = d3.select(this)
                $help_page.select('button.render')
                .on('click', function() {
                    $help_page.select('div.help')
                        .html("")
                        .append(function() {
                            return format($help_page.select('textarea.help').property('value'))
                        });
                })
            }
        },
        route = function(hash) {
            var path_elements = hash.slice(1).split("/"),
                page = path_elements.shift(),
                page_elem = d3.select('#' + page + "_page")[0][0];
            console.debug("Navigating to", page, "(", path_elements, ")");
            if (page) {
                d3.selectAll('.page').
                    style("display", function(d) { return this.id.startsWith(page) ? "block" : "none"; });
                d3.selectAll('#topbar a').
                    classed("active", function(d) { return this.href.slice(1).split("/")[0] == page; });
                routes[page].apply(page_elem, path_elements);
            } else { // Did you really want to navigate to nowhere?
                console.log("hash", hash, "appears to go nowhere");
                d3.selectAll('.page').style("display", "none");
                d3.selectAll('#topbar a').classed("active", false);
            }
        };
    window.addEventListener('hashchange', function() {route(window.location.hash)});
    route(window.location.hash);
});
</script>
</head>
<body>
<div id="topbar">
    <!-- It is assumed that hrefs of all these are hashes --!>
    <a id="login_tab" href="#login">Login</a>
    <a id="register_tab" href="#register">Register</a>
    <a id="posts_tab" href="#posts">Posts</a>
    <a id="profile_tab" href="#profile">Profile</a>
    <a id="help_tab" href="#help">Help</a>
</div>
<div id="login_page" class="page">
    <p class="loggedon"><span>Currently logged in as: </span><span class="user" /></p>
    <p><span>Username:</span><input type="text" class="username" /></p>
    <p><span>Password:</span><input type="password" class="password" /></p>
    <button class="login">login</button> <button class="logout">logout</button>
</div>
<div id="register_page" class="page">
    <p><span>Username (login and URL, immutable):</span><input type="text" class="username" /></p>
    <p><span>Nick (display name, can be changed):</span><input type="text" class="nick" /></p>
    <p><span>Signature (not required):</span><input type="text" class="signature" /></p>
    <p><span>Image URL (not required):</span><input type="text" class="avatar" /></p>
    <p><span>Password:</span><input type="password" class="password" /></p>
    <p><span>Password:</span><input type="password" class="password2" /></p>
    <p><span>Magic Passcode:</span><input type="text" class="passcode" /></p>
    <button class="register">register</button>
</div>
<div id="posts_page" class="page">
    <div id="posts" class="posts">
    <!-- This gets filled out by D3 --!>
    </div>
    <div class="posts">
        <div id="template" class="post">
            <div class="header">
                <div class="miniprofile">
                    <img src="prophat.jpg" class="avatar" />
                    <a class="nick" href="#profile">DJ Tëstio</a>
                    <div class="title">#E_REKT</div>
                </div>
                <input type="hidden" class="id" />
                <input type="hidden" class="owner" />
                <input type="hidden" class="thread_id" />
                <div class="subject">Imma loadin' some posts!</div>
                <div class="lasted">2015-03-11T00:04:20.514Z</div>
                <div class="clearer"></div>
            </div>
            <div class="content">Post pictures of toast.</div>
            <div class="footer">
                <div class="signature"></div>
                <div class="container">
                    <button class="unload">Unload</button>
                    <button class="edit">Edit</button>
                    <button class="save">Save</button>
                    <button class="cancel">Cancel</button>
                    <button class="delete">Delete</button>
                    <button class="load">Load</button>
                    <button class="interject">Interject!</button>
                    <button class="reply">Reply</button>
                </div>
            </div>
        </div>
        <div class="post replyed" style="display: none" id="base_posted">
            <div class="header">
                <div class="miniprofile">
                    <img class="avatar" src="" />
                    <div class="nick"></div>
                    <div class="title"></div>
                </div>
                <input type="hidden" class="owner" value="" />
                <input type="hidden" class="thread_id" />
                <input type="text" class="subject" value="" />
                <div class="lasted">Eventually now.</div>
                <div class="clearer"></div>
            </div>
            <textarea style="display: block" class="content"></textarea>
            <div class="footer">
                <div class="signature"></div>
                <div class="container">
                    <button class="reply">Reply</button>
                </div>
            </div>
        </div>
    </div>
</div>
<div id="profile_page" class="page">
    <table>
        <tr>
            <td class="label">username</td>
            <td><input class="username" type="text" disabled /><span class="username"></span></td>
        </tr>
        <tr>
            <td class="label">nick</td>
            <td><input class="nick" type="text"/><span class="nick"></span></td>
        </tr>
        <tr>
            <td class="label">avatar</td>
            <td><img class="avatar" /><input class="avatar" type="text"/></td>
        </tr>
        <tr>
            <td class="label">signature</td>
            <td><textarea class="signature"></textarea><div class="signature"></span></td>
        </tr>
        <tr class="password">
            <td class="password">password</td>
            <td><input class="password" type="password" /><span class="password"></span></td>
        </tr>
        <tr class="password">
            <td class="password2">password(again to change)</td>
            <td><input class="password2" type="password" /><span class="password"></span></td>
        </tr>
    </table>
    <button class="save">Save</button>
</div>
<div id="help_page" class="page">
    <div class="help"></div>
    <br /> <hr />
    <textarea class="help">
Press "render" below to see what the contents of this box would look like as a post
__this is some underlinetext__
**this is some boldtext**
~~this is some strikethroughtext~~
//this is some italicstext//
You can combine them: //like __this__//
*This
*is
*a
*list
>this is a quote
A link: [https://google.com]
And a picture of a hat: [./prophat.jpg|]
    </textarea><br />
    <button class="render">Render</button>
</div>
</body>
<script>
"use strict";
var urls = {
    "posts": "/posts",
    "thread": "/posts/_design/posts/_view/thread",
    "post": "/posts/_design/posts/_update/post",
    "session": "/_sessions",
    "users": "/_users"
}
if (Element.prototype.closest === undefined) {
    console.log("Registering closest");
    Element.prototype.closest = function(sel) {
        var cur = this.parentNode;
        while(cur !== document && !cur.matches(sel)) {
            cur = cur.parentNode;
        }
        if (cur === document) {
            return null;
        } else {
            return cur;
        }
    }
}
</script>
</html>
